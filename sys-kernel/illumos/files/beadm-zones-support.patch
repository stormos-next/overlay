diff --git a/usr/src/lib/libbe/common/be_activate.c b/usr/src/lib/libbe/common/be_activate.c
index c83e442..e932da5 100644
--- a/usr/src/lib/libbe/common/be_activate.c
+++ b/usr/src/lib/libbe/common/be_activate.c
@@ -131,6 +131,7 @@ _be_activate(char *be_name)
 	be_transaction_data_t cb = { 0 };
 	zfs_handle_t	*zhp = NULL;
 	char		root_ds[MAXPATHLEN];
+	char		active_ds[MAXPATHLEN];
 	char		*cur_vers = NULL, *new_vers = NULL;
 	be_node_list_t	*be_nodes = NULL;
 	uuid_t		uu = {0};
@@ -224,10 +225,13 @@ _be_activate(char *be_name)
 		goto done;
 	}
 
-	if ((ret = set_bootfs(be_nodes->be_rpool, root_ds)) != BE_SUCCESS) {
-		be_print_err(gettext("be_activate: failed to set "
-		    "bootfs pool property for %s\n"), root_ds);
-		goto done;
+	if (getzoneid() == GLOBAL_ZONEID) {
+		if ((ret = set_bootfs(be_nodes->be_rpool,
+		    root_ds)) != BE_SUCCESS) {
+			be_print_err(gettext("be_activate: failed to set "
+			    "bootfs pool property for %s\n"), root_ds);
+			goto done;
+		}
 	}
 
 	if ((zhp = zfs_open(g_zfs, root_ds, ZFS_TYPE_FILESYSTEM)) != NULL) {
@@ -246,7 +250,7 @@ _be_activate(char *be_name)
 			goto done;
 		}
 	} else {
-		be_print_err(gettext("be_activate:: failed to open "
+		be_print_err(gettext("be_activate: failed to open "
 		    "dataset (%s): %s\n"), root_ds,
 		    libzfs_error_description(g_zfs));
 		ret = zfs_err_to_be_err(g_zfs);
@@ -262,6 +266,63 @@ _be_activate(char *be_name)
 		    cb.obe_name);
 	}
 
+	if (getzoneid() != GLOBAL_ZONEID) {
+		int unset_be = B_TRUE;
+
+		if ((zhp = zfs_open(g_zfs, root_ds,
+		    ZFS_TYPE_FILESYSTEM)) == NULL) {
+			be_print_err(gettext("be_activate: failed to open "
+			    "dataset (%s): %s\n"), root_ds,
+			    libzfs_error_description(g_zfs));
+			ret = zfs_err_to_be_err(g_zfs);
+			goto done;
+		}
+
+		/* Find current active zone root dataset */
+		if (be_find_active_zone_root(zhp, cb.obe_zpool,
+		    active_ds, sizeof (active_ds)) != BE_SUCCESS) {
+			unset_be = B_FALSE;
+		/* Requested environment is already active */
+		} else if (strcmp(root_ds, active_ds) == 0) {
+			ZFS_CLOSE(zhp);
+			goto done;
+		}
+
+		/* Set active property for BE */
+		if (zfs_prop_set(zhp, BE_ZONE_ACTIVE_PROPERTY, "on") != 0) {
+			be_print_err(gettext("be_activate: failed to set "
+			    "active property (%s): %s\n"), root_ds,
+			    libzfs_error_description(g_zfs));
+			ret = zfs_err_to_be_err(g_zfs);
+			ZFS_CLOSE(zhp);
+			goto done;
+		}
+		ZFS_CLOSE(zhp);
+
+		/* No environment was set so there's nothing to unset */
+		if (!unset_be) {
+			goto done;
+		}
+
+		/* Unset active property for old active root dataset */
+		if ((zhp = zfs_open(g_zfs, active_ds,
+		    ZFS_TYPE_FILESYSTEM)) == NULL) {
+			be_print_err(gettext("be_activate: failed to open "
+			    "dataset (%s): %s\n"), active_ds,
+			    libzfs_error_description(g_zfs));
+			ret = zfs_err_to_be_err(g_zfs);
+			goto done;
+		}
+		if (zfs_prop_set(zhp, BE_ZONE_ACTIVE_PROPERTY, "off") != 0) {
+			be_print_err(gettext("be_activate: failed to unset "
+			    "active property (%s): %s\n"), active_ds,
+			    libzfs_error_description(g_zfs));
+			ret = zfs_err_to_be_err(g_zfs);
+			ZFS_CLOSE(zhp);
+			goto done;
+		}
+		ZFS_CLOSE(zhp);
+	}
 done:
 	be_free_list(be_nodes);
 	return (ret);
diff --git a/usr/src/lib/libbe/common/be_create.c b/usr/src/lib/libbe/common/be_create.c
index 48bf4ec..7dd515b 100644
--- a/usr/src/lib/libbe/common/be_create.c
+++ b/usr/src/lib/libbe/common/be_create.c
@@ -482,9 +482,12 @@ be_destroy(nvlist_t *be_attrs)
 	}
 
 	/* Get the UUID of the global BE */
-	if (be_get_uuid(zfs_get_name(zhp), &dd.gz_be_uuid) != BE_SUCCESS) {
-		be_print_err(gettext("be_destroy: BE has no UUID (%s)\n"),
-		    zfs_get_name(zhp));
+	if (getzoneid() == GLOBAL_ZONEID) {
+		if (be_get_uuid(zfs_get_name(zhp),
+		    &dd.gz_be_uuid) != BE_SUCCESS) {
+			be_print_err(gettext("be_destroy: BE has no "
+			"UUID (%s)\n"), zfs_get_name(zhp));
+		}
 	}
 
 	/*
@@ -595,6 +598,7 @@ be_copy(nvlist_t *be_attrs)
 	zpool_handle_t	*zphp = NULL;
 	nvlist_t	*zfs_props = NULL;
 	uuid_t		uu = { 0 };
+	uuid_t		parent_uu = { 0 };
 	char		obe_root_ds[MAXPATHLEN];
 	char		nbe_root_ds[MAXPATHLEN];
 	char		ss[MAXPATHLEN];
@@ -753,17 +757,30 @@ be_copy(nvlist_t *be_attrs)
 		}
 
 		/* Verify it doesn't already exist */
-		if ((zret = zpool_iter(g_zfs, be_exists_callback, bt.nbe_name))
-		    > 0) {
-			be_print_err(gettext("be_copy: BE (%s) already "
-			    "exists\n"), bt.nbe_name);
-			ret = BE_ERR_BE_EXISTS;
-			goto done;
-		} else if (zret < 0) {
-			be_print_err(gettext("be_copy: zpool_iter failed: "
-			    "%s\n"), libzfs_error_description(g_zfs));
-			ret = zfs_err_to_be_err(g_zfs);
-			goto done;
+		if (getzoneid() == GLOBAL_ZONEID) {
+			if ((zret = zpool_iter(g_zfs, be_exists_callback,
+			    bt.nbe_name)) > 0) {
+				be_print_err(gettext("be_copy: BE (%s) already "
+				    "exists\n"), bt.nbe_name);
+				ret = BE_ERR_BE_EXISTS;
+				goto done;
+			} else if (zret < 0) {
+				be_print_err(gettext("be_copy: zpool_iter "
+				    "failed: %s\n"),
+				    libzfs_error_description(g_zfs));
+				ret = zfs_err_to_be_err(g_zfs);
+				goto done;
+			}
+		} else {
+			be_make_root_ds(bt.nbe_zpool, bt.nbe_name, nbe_root_ds,
+			    sizeof (nbe_root_ds));
+			if (zfs_dataset_exists(g_zfs, nbe_root_ds,
+			    ZFS_TYPE_FILESYSTEM)) {
+				be_print_err(gettext("be_copy: BE (%s) already "
+				    "exists\n"), bt.nbe_name);
+				ret = BE_ERR_BE_EXISTS;
+				goto done;
+			}
 		}
 	} else {
 		/*
@@ -1016,9 +1033,24 @@ be_copy(nvlist_t *be_attrs)
 	}
 
 	/* Set UUID for new BE */
-	if (be_set_uuid(bt.nbe_root_ds) != BE_SUCCESS) {
-		be_print_err(gettext("be_copy: failed to "
-		    "set uuid for new BE\n"));
+	if (getzoneid() == GLOBAL_ZONEID) {
+		if (be_set_uuid(bt.nbe_root_ds) != BE_SUCCESS) {
+			be_print_err(gettext("be_copy: failed to "
+			    "set uuid for new BE\n"));
+		}
+	} else {
+		if ((ret = be_zone_get_parent_uuid(bt.obe_root_ds,
+		    &parent_uu)) != BE_SUCCESS) {
+			be_print_err(gettext("be_copy: failed to get "
+			    "parentbe uuid from orig BE\n"));
+			ret = BE_ERR_ZONE_NO_PARENTBE;
+			goto done;
+		} else if ((ret = be_zone_set_parent_uuid(bt.nbe_root_ds,
+		    parent_uu)) != BE_SUCCESS) {
+			be_print_err(gettext("be_copy: failed to set "
+			    "parentbe uuid for newly created BE\n"));
+			goto done;
+		}
 	}
 
 	/*
diff --git a/usr/src/lib/libbe/common/be_list.c b/usr/src/lib/libbe/common/be_list.c
index b9c7882..030ff55 100644
--- a/usr/src/lib/libbe/common/be_list.c
+++ b/usr/src/lib/libbe/common/be_list.c
@@ -824,7 +824,9 @@ be_get_node_data(
 	char prop_buf[MAXPATHLEN];
 	nvlist_t *userprops = NULL;
 	nvlist_t *propval = NULL;
+	nvlist_t *zone_propval = NULL;
 	char *prop_str = NULL;
+	char *zone_prop_str = NULL;
 	char *grub_default_bootfs = NULL;
 	zpool_handle_t *zphp = NULL;
 	int err = 0;
@@ -865,27 +867,30 @@ be_get_node_data(
 
 	be_node->be_space_used = zfs_prop_get_int(zhp, ZFS_PROP_USED);
 
-	if ((zphp = zpool_open(g_zfs, rpool)) == NULL) {
-		be_print_err(gettext("be_get_node_data: failed to open pool "
-		    "(%s): %s\n"), rpool, libzfs_error_description(g_zfs));
-		return (zfs_err_to_be_err(g_zfs));
-	}
+	if (getzoneid() == GLOBAL_ZONEID) {
+		if ((zphp = zpool_open(g_zfs, rpool)) == NULL) {
+			be_print_err(gettext("be_get_node_data: failed to open "
+			    "pool (%s): %s\n"), rpool,
+			    libzfs_error_description(g_zfs));
+			return (zfs_err_to_be_err(g_zfs));
+		}
 
-	(void) zpool_get_prop(zphp, ZPOOL_PROP_BOOTFS, prop_buf, ZFS_MAXPROPLEN,
-	    NULL);
-	if (be_has_grub() &&
-	    (be_default_grub_bootfs(rpool, &grub_default_bootfs)
-	    == BE_SUCCESS) && grub_default_bootfs != NULL)
-		if (strcmp(grub_default_bootfs, be_ds) == 0)
+		(void) zpool_get_prop(zphp, ZPOOL_PROP_BOOTFS, prop_buf,
+		    ZFS_MAXPROPLEN, NULL);
+		if (be_has_grub() && (be_default_grub_bootfs(rpool,
+		    &grub_default_bootfs) == BE_SUCCESS) &&
+		    grub_default_bootfs != NULL)
+			if (strcmp(grub_default_bootfs, be_ds) == 0)
+				be_node->be_active_on_boot = B_TRUE;
+			else
+				be_node->be_active_on_boot = B_FALSE;
+		else if (prop_buf != NULL && strcmp(prop_buf, be_ds) == 0)
 			be_node->be_active_on_boot = B_TRUE;
 		else
 			be_node->be_active_on_boot = B_FALSE;
-	else if (prop_buf != NULL && strcmp(prop_buf, be_ds) == 0)
-		be_node->be_active_on_boot = B_TRUE;
-	else
-		be_node->be_active_on_boot = B_FALSE;
-	free(grub_default_bootfs);
-	zpool_close(zphp);
+		free(grub_default_bootfs);
+		zpool_close(zphp);
+	}
 
 	/*
 	 * If the dataset is mounted use the mount point
@@ -910,6 +915,22 @@ be_get_node_data(
 	if ((userprops = zfs_get_user_props(zhp)) == NULL) {
 		be_node->be_policy_type = strdup(be_default_policy());
 	} else {
+		if (getzoneid() != GLOBAL_ZONEID) {
+			if (nvlist_lookup_nvlist(userprops,
+			    BE_ZONE_ACTIVE_PROPERTY, &zone_propval) != 0 ||
+			    zone_propval == NULL) {
+				be_node->be_active_on_boot = B_FALSE;
+			} else {
+				verify(nvlist_lookup_string(zone_propval,
+				    ZPROP_VALUE, &zone_prop_str) == 0);
+				if (strcmp(zone_prop_str, "on") == 0) {
+					be_node->be_active_on_boot = B_TRUE;
+				} else {
+					be_node->be_active_on_boot = B_FALSE;
+				}
+			}
+		}
+
 		if (nvlist_lookup_nvlist(userprops, BE_POLICY_PROPERTY,
 		    &propval) != 0 || propval == NULL) {
 			be_node->be_policy_type =
@@ -924,11 +945,19 @@ be_get_node_data(
 			else
 				be_node->be_policy_type = strdup(prop_str);
 		}
-
-		if (nvlist_lookup_nvlist(userprops, BE_UUID_PROPERTY, &propval)
-		    == 0 && nvlist_lookup_string(propval, ZPROP_VALUE,
-		    &prop_str) == 0) {
-			be_node->be_uuid_str = strdup(prop_str);
+		if (getzoneid() != GLOBAL_ZONEID) {
+			if (nvlist_lookup_nvlist(userprops,
+			    BE_ZONE_PARENTBE_PROPERTY, &propval) != 0 &&
+			    nvlist_lookup_string(propval, ZPROP_VALUE,
+			    &prop_str) == 0) {
+				be_node->be_uuid_str = strdup(prop_str);
+			}
+		} else {
+			if (nvlist_lookup_nvlist(userprops, BE_UUID_PROPERTY,
+			    &propval) == 0 && nvlist_lookup_string(propval,
+			    ZPROP_VALUE, &prop_str) == 0) {
+				be_node->be_uuid_str = strdup(prop_str);
+			}
 		}
 	}
 
diff --git a/usr/src/lib/libbe/common/be_mount.c b/usr/src/lib/libbe/common/be_mount.c
index 6c631da..b8d98d3 100644
--- a/usr/src/lib/libbe/common/be_mount.c
+++ b/usr/src/lib/libbe/common/be_mount.c
@@ -533,6 +533,21 @@ _be_unmount(char *be_name, int flags)
 		return (ret);
 	}
 
+	/* Zone's root mountpoint property must be set to 'legacy' */
+	if (getzoneid() != GLOBAL_ZONEID) {
+		if (strcmp(mountpoint, ZFS_MOUNTPOINT_LEGACY) != 0) {
+			if (zfs_prop_set(zhp,
+			    zfs_prop_to_name(ZFS_PROP_MOUNTPOINT),
+			    ZFS_MOUNTPOINT_LEGACY) != 0) {
+				be_print_err(gettext("be_unmount: failed to "
+				    "set mountpoint of zone root dataset %s "
+				    "to 'legacy': %s\n"), zfs_get_name(zhp),
+				    libzfs_error_description(g_zfs));
+				return (zfs_err_to_be_err(g_zfs));
+			}
+		}
+	}
+
 	ZFS_CLOSE(zhp);
 
 	return (BE_SUCCESS);
diff --git a/usr/src/lib/libbe/common/be_snapshot.c b/usr/src/lib/libbe/common/be_snapshot.c
index 2cb011e..4a09a96 100644
--- a/usr/src/lib/libbe/common/be_snapshot.c
+++ b/usr/src/lib/libbe/common/be_snapshot.c
@@ -482,27 +482,30 @@ _be_create_snapshot(char *be_name, char **snap_name, char *policy)
 	 * cleanup policy there.  Otherwise don't set one - this snapshot
 	 * will always inherit the cleanup policy from its parent.
 	 */
-	if (pool_version >= SPA_VERSION_SNAP_PROPS) {
-		if (nvlist_alloc(&ss_props, NV_UNIQUE_NAME, 0) != 0) {
-			be_print_err(gettext("be_create_snapshot: internal "
-			    "error: out of memory\n"));
-			return (BE_ERR_NOMEM);
-		}
-		if (nvlist_add_string(ss_props, BE_POLICY_PROPERTY, bt.policy)
-		    != 0) {
-			be_print_err(gettext("be_create_snapshot: internal "
-			    "error: out of memory\n"));
-			nvlist_free(ss_props);
-			return (BE_ERR_NOMEM);
+	if (getzoneid() == GLOBAL_ZONEID) {
+		if (pool_version >= SPA_VERSION_SNAP_PROPS) {
+			if (nvlist_alloc(&ss_props, NV_UNIQUE_NAME, 0) != 0) {
+				be_print_err(gettext("be_create_snapshot: "
+				    "internal error: out of memory\n"));
+				return (BE_ERR_NOMEM);
+			}
+			if (nvlist_add_string(ss_props, BE_POLICY_PROPERTY,
+			    bt.policy) != 0) {
+				be_print_err(gettext("be_create_snapshot: "
+				    "internal error: out of memory\n"));
+				nvlist_free(ss_props);
+				return (BE_ERR_NOMEM);
+			}
+		} else if (policy != NULL) {
+			/*
+			 * If an explicit cleanup policy was requested
+			 * by the caller and we don't support it, error out.
+			 */
+			be_print_err(gettext("be_create_snapshot: cannot set "
+			    "cleanup policy: ZFS pool version is %d\n"),
+			    pool_version);
+			return (BE_ERR_NOTSUP);
 		}
-	} else if (policy != NULL) {
-		/*
-		 * If an explicit cleanup policy was requested
-		 * by the caller and we don't support it, error out.
-		 */
-		be_print_err(gettext("be_create_snapshot: cannot set "
-		    "cleanup policy: ZFS pool version is %d\n"), pool_version);
-		return (BE_ERR_NOTSUP);
 	}
 
 	/* Create the snapshots recursively */
diff --git a/usr/src/lib/libbe/common/be_utils.c b/usr/src/lib/libbe/common/be_utils.c
index 888a8e2..56926a9 100644
--- a/usr/src/lib/libbe/common/be_utils.c
+++ b/usr/src/lib/libbe/common/be_utils.c
@@ -53,6 +53,7 @@
 #include <deflt.h>
 #include <wait.h>
 #include <libdevinfo.h>
+#include <libgen.h>
 
 #include <libbe.h>
 #include <libbe_priv.h>
@@ -230,13 +231,30 @@ be_make_root_ds(const char *zpool, const char *be_name, char *be_root_ds,
 {
 	struct be_defaults be_defaults;
 	be_get_defaults(&be_defaults);
+	char	*root_ds = NULL;
 
-	if (be_defaults.be_deflt_rpool_container)
-		(void) snprintf(be_root_ds, be_root_ds_size, "%s/%s", zpool,
-		    be_name);
-	else
-		(void) snprintf(be_root_ds, be_root_ds_size, "%s/%s/%s", zpool,
-		    BE_CONTAINER_DS_NAME, be_name);
+	if (getzoneid() == GLOBAL_ZONEID) {
+		if (be_defaults.be_deflt_rpool_container) {
+			(void) snprintf(be_root_ds, be_root_ds_size,
+			    "%s/%s", zpool, be_name);
+		} else {
+			(void) snprintf(be_root_ds, be_root_ds_size,
+			    "%s/%s/%s", zpool, BE_CONTAINER_DS_NAME, be_name);
+		}
+	} else {
+		/*
+		 * In non-global zone we can use path from mounted root dataset
+		 * to generate BE's root dataset string.
+		 */
+		if ((root_ds = be_get_ds_from_dir("/")) != NULL) {
+			(void) snprintf(be_root_ds, be_root_ds_size, "%s/%s",
+			    dirname(root_ds), be_name);
+		} else {
+			be_print_err(gettext("be_make_root_ds: zone root "
+			    "dataset is not mounted\n"));
+			return;
+		}
+	}
 }
 
 /*
@@ -258,12 +276,26 @@ be_make_container_ds(const char *zpool,  char *container_ds,
 {
 	struct be_defaults be_defaults;
 	be_get_defaults(&be_defaults);
+	char	*root_ds = NULL;
 
-	if (be_defaults.be_deflt_rpool_container)
-		(void) snprintf(container_ds, container_ds_size, "%s", zpool);
-	else
-		(void) snprintf(container_ds, container_ds_size, "%s/%s", zpool,
-		    BE_CONTAINER_DS_NAME);
+	if (getzoneid() == GLOBAL_ZONEID) {
+		if (be_defaults.be_deflt_rpool_container) {
+			(void) snprintf(container_ds, container_ds_size,
+			    "%s", zpool);
+		} else {
+			(void) snprintf(container_ds, container_ds_size,
+			    "%s/%s", zpool, BE_CONTAINER_DS_NAME);
+		}
+	} else {
+		if ((root_ds = be_get_ds_from_dir("/")) != NULL) {
+			(void) strlcpy(container_ds, dirname(root_ds),
+			    container_ds_size);
+		} else {
+			be_print_err(gettext("be_make_container_ds: zone root "
+			    "dataset is not mounted\n"));
+			return;
+		}
+	}
 }
 
 /*
@@ -2436,11 +2468,25 @@ be_zpool_find_current_be_callback(zpool_handle_t *zlp, void *data)
 	zfs_handle_t		*zhp = NULL;
 	const char		*zpool =  zpool_get_name(zlp);
 	char			be_container_ds[MAXPATHLEN];
+	char			*zpath = NULL;
 
 	/*
 	 * Generate string for BE container dataset
 	 */
-	be_make_container_ds(zpool, be_container_ds, sizeof (be_container_ds));
+	if (getzoneid() != GLOBAL_ZONEID) {
+		if ((zpath = be_get_ds_from_dir("/")) != NULL) {
+			(void) strlcpy(be_container_ds, dirname(zpath),
+			    sizeof (be_container_ds));
+		} else {
+			be_print_err(gettext(
+			    "be_zpool_find_current_be_callback: "
+			    "zone root dataset is not mounted\n"));
+			return (0);
+		}
+	} else {
+		be_make_container_ds(zpool, be_container_ds,
+		    sizeof (be_container_ds));
+	}
 
 	/*
 	 * Check if a BE container dataset exists in this pool.
diff --git a/usr/src/lib/libbe/common/be_zones.c b/usr/src/lib/libbe/common/be_zones.c
index 886b0da..d9c21b3 100644
--- a/usr/src/lib/libbe/common/be_zones.c
+++ b/usr/src/lib/libbe/common/be_zones.c
@@ -113,13 +113,23 @@ be_find_active_zone_root(zfs_handle_t *be_zhp, char *zonepath_ds,
 	int				ret = BE_SUCCESS;
 
 	/* Get the uuid of the parent global BE */
-	if ((ret = be_get_uuid(zfs_get_name(be_zhp), &azr_data.parent_uuid))
-	    != BE_SUCCESS) {
-		be_print_err(gettext("be_find_active_zone_root: failed to "
-		    "get uuid for BE root dataset %s\n"), zfs_get_name(be_zhp));
-		return (ret);
+	if (getzoneid() == GLOBAL_ZONEID) {
+		if ((ret = be_get_uuid(zfs_get_name(be_zhp),
+		    &azr_data.parent_uuid)) != BE_SUCCESS) {
+			be_print_err(gettext("be_find_active_zone_root: failed "
+			    "to get uuid for BE root dataset %s\n"),
+			    zfs_get_name(be_zhp));
+			return (ret);
+		}
+	} else {
+		if ((ret = be_zone_get_parent_uuid(zfs_get_name(be_zhp),
+		    &azr_data.parent_uuid)) != BE_SUCCESS) {
+			be_print_err(gettext("be_find_active_zone_root: failed "
+			    "to get parentbe uuid for zone root dataset %s\n"),
+			    zfs_get_name(be_zhp));
+			return (ret);
+		}
 	}
-
 	/* Generate string for the root container dataset for this zone. */
 	be_make_container_ds(zonepath_ds, zone_container_ds,
 	    sizeof (zone_container_ds));
@@ -376,6 +386,47 @@ done:
 	return (ret);
 }
 
+/*
+ * Function:	be_zone_set_parent_uuid
+ * Description:	This function sets parentbe uuid into
+ *		a zfs user property for a root zone dataset.
+ * Parameters:
+ *		root_ds - Root zone dataset of the BE to set a uuid on.
+ * Return:
+ *		be_errno_t - Failure
+ *		BE_SUCCESS - Success
+ * Scope:
+ *		Semi-private (library wide uses only)
+ */
+int
+be_zone_set_parent_uuid(char *root_ds, uuid_t uu)
+{
+	zfs_handle_t	*zhp = NULL;
+	char		uu_string[UUID_PRINTABLE_STRING_LENGTH];
+	int		ret = BE_SUCCESS;
+
+	uuid_unparse(uu, uu_string);
+
+	/* Get handle to the root zone dataset. */
+	if ((zhp = zfs_open(g_zfs, root_ds, ZFS_TYPE_FILESYSTEM)) == NULL) {
+		be_print_err(gettext("be_zone_set_parent_uuid: failed to "
+		    "open root zone dataset (%s): %s\n"), root_ds,
+		    libzfs_error_description(g_zfs));
+		return (zfs_err_to_be_err(g_zfs));
+	}
+
+	/* Set parentbe uuid property for the root zone dataset */
+	if (zfs_prop_set(zhp, BE_ZONE_PARENTBE_PROPERTY, uu_string) != 0) {
+		be_print_err(gettext("be_zone_set_parent_uuid: failed to "
+		    "set parentbe uuid property for root zone dataset: %s\n"),
+		    libzfs_error_description(g_zfs));
+		ret = zfs_err_to_be_err(g_zfs);
+	}
+
+	ZFS_CLOSE(zhp);
+	return (ret);
+}
+
 /* ******************************************************************** */
 /*			Private Functions				*/
 /* ******************************************************************** */
diff --git a/usr/src/lib/libbe/common/libbe_priv.h b/usr/src/lib/libbe/common/libbe_priv.h
index 7e79c79..554bae0 100644
--- a/usr/src/lib/libbe/common/libbe_priv.h
+++ b/usr/src/lib/libbe/common/libbe_priv.h
@@ -205,6 +205,7 @@ int be_find_mounted_zone_root(char *, char *, char *, int);
 boolean_t be_zone_supported(char *);
 zoneBrandList_t *be_get_supported_brandlist(void);
 int be_zone_get_parent_uuid(const char *, uuid_t *);
+int be_zone_set_parent_uuid(char *, uuid_t);
 
 /* check architecture functions */
 char *be_get_default_isa(void);
